# Toolkit

Some useful tools for the second part of the Cybersecurity course @UniPd


## Requirements
- Disassembler -> we use ***Ida***
    - *to download Ida (free version):* https://www.hex-rays.com/ida-free/
- Hexadecimal editor -> we use ***Radare2*** (alternative: *Hex Editor*)
    - *to download Radare:* https://github.com/radareorg/radare2
- Debugger -> we use ***GDB***
    - it should already been installed if you have Linux *(on Windows you will need to install it, please note that in this case MinGW distributes a Windows version of it)*
- Other tools useful for pwning:
    - ***PEDA*** *(i.e. Python Exploit Development Assistance for GDB)* available to download at: https://github.com/longld/peda
    - ***pwntool*** *(python library)*, available to download at: http://docs.pwntools.com/en/stable/ or simply by doing ```pip install pwntools```

> ***PLEASE NOTE:***  Before doing anything it's necessary to change the permissions of the directory we want to work on. We can achieve this with:   ``` chmod -R +x ./ ```


## Some useful commands
Let's see some commands (available to use on terminal) that might be useful for Reverse Engineering and Pwning:
- ***./name_of_the_program***
    - to simply run a program in the terminal
- ***cat ./text_file***
    - to read the files specified as parameters and display the concatenation of their content
- ***strings ./name_of_the_program***
    - to display all the strings used inside the program (e.g. if there is a psw or a flag stored it should appear)
- ***objdump -option ./name_of_the_program***
    - to display information about one or more object files. The options control what particular information to display, we can for example choose the option:
        - ***-d*** (--disassemble) which display the ASM code of the input files.
        - ***--dynamic-reloc*** to see where the GOT entry for a function is, i.e. it prints the real address of the functions (and if the function was not already used the address of the linker)
- ***checksec ./name_of_the_program***
    - to display details (+ security properties) regarding the executable file *(e.g. architecture 32bit/64bit so we know the size of the registers)*. In particular, it outputs:
        1. the architecture (32-64bit + little/big endian)
        2. RELRO, which stands for *Relocation Read-Only*, and if enabled (completely) it makes the GOT *(i.e. the "Global Offset Table" of ELF executable files used to resolve functions dynamically)* read-only, which prevents some form of relocation attacks (GOT hijacking). If enabled partially, it makes only the global variables read-only.
        3. CANARY, they are special known values placed  between a buffer and control data on the stack to monitor buffer overflows. In this way, they can control that the function return to the real previous function
        4. NX, which stands for *Non-Executable*, it's often enabled by default and in that case the stack is non-executable (basically NX enabled can mark certain areas of memory as non-executable). This is done because often buffer-overflow exploits put code on the stack and then try to execute it. However, making this writable area non-executable can prevent such attacks.
        5. PIE, which stands for *Position Independent Executable*,  it's code that is placed somewhere in memory for execution regardless of its absolute address (basically the addresses are shifted of a (common) offset. 


## Ida
### Ida basics 
To open Ida from terminal:
```
cd idafree-8.1/
./ida64
```
To disassemble a file click on *New* and then *Ok* on the *Quick Start* window that opens up. You should now see all the ASM code of the program on the right side 
(included the branches generated by the jump instructions) and the various functions on the left side.
You can also change the view from "graph view" to "text view" by simply pressing the space bar on the keyboard.

From "text view" we are now able to patch the instructions by doing: ``` Edit -> Patch program -> Assemble ``` . Once we have changed/patched the instruction (and clicked on OK), then we need to actually apply the patch to the original program by doing: ``` Edit -> Patch program -> Apply patches to input file -> OK ```.

> ***PLEASE NOTE:*** When changing the type of view in Ida, if we have highlighted/selected some instruction, we will be able to see that instruction highlighted/selected in the other type of view as well.

### Patching with Ida
We can also patch instructions on Ida by changing the actual hexadecimal values. We pass to "Hex View" so we can see the hex of the instruction we want to patch. Then as before we can patch it by doing: ``` Edit -> Patch program -> Patch byte ``` and then apply the patch to the original program as before.

> ***PLEASE NOTE:*** The instructions are identified in hex with their opcode. So if you want to change an instruction you need to change the hex/opcode with the one you want. You can find all the opcodes with the corresponding instruction at: http://ref.x86asm.net/coder64.html 
In particular, please note that the opcode for the NOP instruction is 90.

This is the same as [Patching with Radare2](#Patching-with-Radare2)


## Radare2
### Radare2 basics
Radare2 is very useful for patching *(e.g. we can fill with NOP, invert or remove them and also paste new functions)*. In particular, we can use it for change some constant (since the free version of Ida doesn't really allow us to do so).

Let's see some Radare commands (that we use on the terminal) that help us doing it:
- To open the file using Radare2 *(-w to enable writing on it)* and launch tha analysis:
    ```
    r2 -w name_of_the_file
    aaaa
    ```
    > ***PLEASE NOTE:*** it's recommended doing a copy of the file and working with radare on it, rather than the original one
- To move to the start of a function or a specific address:
    ```C
    s name_of_the_function
    //or similarly
    s address
    ```
- To print the the decompiled function (once you've moved to the corresponding memory address) simply use:
    ```
    pdf
    ```
    In this way you will be able to see on your left the memory addresses, on the center the bytes that make up the instructions and on the right the instructions themselves.
- To disply all the functions and their memory address where they're store we simply use:
    ```C
    afl     //which stands for Analyse Function List
    ```

### Patching with Radare2
To patch the instruction (once you've moved to the corresponding memory address) you can use:
```C
//to patch the assembly instructions
wa new_instruction_in_ASM
//to patch the bytes
wx new_bytes
```
> ***PLEASE NOTE:*** you can double check the correctness of the patch with ```pdf```

This is the same as [Patching with Ida](#Patching-with-Ida)



## GDB (included PEDA)
### GDB basics
To run a file using GDB, i.e. debugging it:
```C
gdb name_of_the_file
//to initially run the program and make it stop at the most convenient spot:
start
```
or also
```C
gdb name_of_the_file
//add breakpoints
run
```
In this last way, the program will stop at the first breakpoint *(please note that if there are no breakpoints, it will run your program to completion without debugging it at all, unless of course the program crashes. In that case, gdb will stop and allow you to debug it)*. 

> ***PLEASE NOTE:*** If you don't add breakpoints, you can still stop the program while it's running by typing ```(ctrl) + c```. Gdb will stop your program at whatever line it has just executed. From here you can examine variables and move through your program.

### About breakpoints (and how to resume the program)
To add a breakpoint:
```C
b*memory_address
//or similarly
break name_of_the_function
```

> ***PLEASE NOTE:*** Breakpoints stay set when your program ends, so you do not have to reset them unless you quit gdb and restart it. 

Other useful commands regarding breakpoints:
- To list current breakpoints: ```info break```
- To delete a breakpoint: ```del breakpoint_number```
- To delete all breakpoints from a specific function: ```clear name_of_the_function```
- To temporarily disable a breakpoint: ```dis breakpoint_number```
- To enable a breakpoint: ```en breakpoint_number```
- To ignore a breakpoint until it has been crossed x times: ```ignore breakpoint_number x```

On the other hand you might want:
- To execute one line of code:
    - just type ```step``` or ```s```. If the line to be executed is a function call, gdb will step into that function and start executing its code one line at a time. If you want to execute the entire function with one keypress, type ```next``` or ```n```.
- To resume normal execution:
    - just type ```continue``` or ```c```. In this way, gdb will run until your program ends, your program crashes, or gdb encounters a breakpoint. 
    > ***PLEASE NOTE:***  In this way you can also loop the program n times just by typing: ```c n_times```
- To resume execution at another function of the program:
    - just type ```jump name_of_the_function ```

### Examining data with gdb
To show information about the current state of the program you can use the keyword info, for example:
- to show the current conent of the registers type ``` info registers ```
- to show the current variables type ``` info variables ```

> ***PLEASE NOTE:*** If you just type info, it will show you all the possible subcommands.

Sometimes, the content of register or variables might be an hexadecimal (in the form 0x...), so it might be useful to print the variable as a string. This is (of course) only possible when the program has been runned and it's stopped at a breakpoint and can simply be achieved by typing:
```C
printf "%s", (char *) var_address       // (char*) is in brackets because is optional
//or similarly
x/s var_address        // in general  is i
```
> ***PLEASE NOTE:*** We use in general ```x / Format Address_expression``` to show in a specific format *(i.e. s for strings, b for bytes...)* a piece of memory, which could be an address in hexadecimal or a register (in this case remember to use $ before the name of the register). *Example: we use ```x/200bx $esp``` to display the stack in bytes (x for hexadecimal which is optional since is the default). Alternatively, we could use rsp instead of esp but the syntax is the same*.

Other commands used to examine data when your program is stopped:
   - To check the assembly code of the program:
        - type ```disassemble name_of_the_function``` or ```disas name_of_the_function```
   - To show all the calls done until that moment:
        - type ```bt```, which stands for *backtrace*

### Cyclic patterns
When trying to pwn and, in particular, trying to do a stack overflow, it might be tricky to find the return address from the start of the buffer (that we want to overflow). To help us find it we can create a pattern (cyclic) and insert it into the buffer in order to see what part of the pattern overwrites the return address.
In this way, we can understand the difference in bytes, i.e. the offset (ret_addr - buff_addr), which is the "garbage"/"padding" we need to put in the buffer to overflow it and reach the start of the return address (where we will put our new address). Basically our input will then be ```garbage_of_length_offset + address_we_want_to_reach```.
- To create the pattern we can use the command: 
    ```
    pattern_create n name_of_the_pattern_file
    ``` 
    where:
    - *n* reppresent the length of the pattern which must be way bigger than the size of the buffer *(e.g. if the buffer size is 128, we can create a pattern long 300)
    - *name_of_the_pattern_file* rappresent the new file which will be created in the current directoy to save the pattern
- To run the program using a pattern as input:
    ```C
    r < name_of_the_pattern_file  
    // or similarly 
    run < name_of_the_pattern_file
    ```
    This should cause a segmentation fault and create an errore in the PC address (i.e. the IP, instruction Pointer) which will result invalid and which correspond to a piece of our pattern. 
- To finally see the offset we can type on the terminal:
    ```
    pattern search
    ```
    We look at the registers that contain our pattern, and in particular to the IP/PC one (which name is EIP). It will show the offset we were looking for.

> ***PLEASE NOTE:*** If the program crash but there are no information about the IP address not being valid, we can search for the pattern code that cause the crash by looking at the character displayed in the stack (the upper frame), usually the first 8 chars are enough, and then search them with ```pattern search stack_chars```. Then we look at the register containing the pattern, and in particular at the RSP/ESP (the stack pointer), and it will show the offset we were looking for.


## Pwntools
### Basics: Processes and Communication
In this course, we aim to corrupt the memory of programs mainly by overflowing buffers. However, since sometimes it's time-consuming to do this by hand we can use a python script to do this for us. This is possible thanks to a python library called pwntools.

Firstly, we need to include the library pwntools in our python script:
```python
from pwn import *
```

Generally, then you will have to create a *"tube"* to talk to a process (i.e. connecting the script with the process you want to pwn). This can be achieved by creating a process object just like this:
```python
new_obj_name = process(path/name_of_the_process)
```
> ***PLEASE NOTE:*** from now on we will call *"new_obj_name"* just *"p"* (which stands for process) for convenience.


Since many settings in pwntools (such as selected target operating system, architecture, and bit-width) are controlled via the global variable *context*, it may be needed to set it correctly (for example in order to have a working shellcode). The recommended methos is to use:
```python
context.binary = "./name_of_the_program"
```
which will set all appropriate values automatically (by absorbing all settings from an ELF file)

> ***PLEASE NOTE:***  It's important to know that ```context.binary``` is an ELF object and actually we can say that:
> ```python
> name_of_elf_object = context.binary
> ``` 
> is the same of doing (as seen in the [elf session](#ELF):
> ```python
> name_of_elf_object = ELF('path/name_of_the_program')
> ```
> Basically is the ELF of the binary program given before (i.e. *./name_of_the_program*).

> ***PLEASE NOTE:*** If we have setted the context.binary, to talk to the process we can do instead of doing ```process(path/name_of_the_process)``` we can do:
> ```python
> p = process(context.binary.path)
> #or simply just
> p = process()     #it's assumed to use that process context binary
> ```

Once we have written our python script we can run it from terminal by doing:
```
python name_of_the_script
```

### Sending and receiving data from processes
Now that we have a connection between the process and the python script we can use different (pwntool's) functions depending on our aim:
- To send data
    ```python
    p.send(data)              #sends data to the process (as if writing a string in terminal)    
    p.sendline(line)          #sends data plus a newline to the process (as if writing a string in terminal)  
    p.sendlineafter("_str_", line)      #sends data to the process (as if writing a string in terminal) only after reading a string specified by _str_ 
    p.pack(data_to_pack)       #packs into a word-size an arbitrary-sized integer and sends it to the process
    ```
     > ***PLEASE NOTE:*** We can send the data to the process packed as bytes using the syntax ```b'string'``` (or with ```("string").encode('ascii')```) instead of strings, since sometimes there can be some problems with them. 
- To receive data
    ```python
    msg = p.recvall()           #msg will store all the prints from the execution in terminal of the process
    msg = p.recv(n)             #as above, but it will receive any number (n) of available bytes
    msg = p.recvline()          #receive data until a newline is encountered
    msg = unpack()              #receives and unpacks a word-size integer
    ```

### Logging 
Logging is a very useful feature of pwntools that lets you know where in your code you've gotten up to, basically it's used to print stuff in the terminal about what you're doing when you're actually executing the python script. You can log in different ways for different types of data.
- log.info(text)
    - used to print ```[*] text```, meaning informative data
- log.success(text)
    - used to print ```[+] text```, meaning a message of success
- log.error(text)
    - used to print ```[-] text```, meaning a message of error/fail

### Packing
To pack data *(e.g. from the address in hex 0x... to bytes)* pwntools uses the *context* global variable (by default little endian) to automatically calculate how the packing should work. This is possible thanks to the function:
```python
//if we compile in a 64-bit architecture (i.e. packed integers have a size of 64 bit)
packed_bytes = p64(data_to_pack)
//or if we compile in a 32-bit architecture (i.e. packed integers have a size of 32 bit)
packed_bytes = p32(data_to_pack)
```
> ***PLEASE NOTE:*** p64() returns a bytes-like object *(e.g. b'some_bytes')*, so if you need to add padding to it remember to use b'A' instead of using just 'A'.

> ***PLEASE NOTE:*** It's also possible to unpack bytes by using ```u64(packed_bytes)```, which is the exact opposite of p64().


### Interactive sessions
We might also want to interact derectly with our process (on the terminal), i.e. we want to use the process in interactive mode to send commands and receive output from the process at runtime.
We do this using:
```python
# exploit goes here
p.interactive()
```
 > ***PLEASE NOTE:***  This is very common when the exercise involves the opening of a shell *(then you can use as a normal shell)*. So in this case remember to use this interactive mode rather than doing a recvall() which will not do anything good (the python script will continue to run and never stop).

To create a shell using pwntools we can simply do:
```python
shellcode = asm(shellcraft.sh())
```
Then if we are able to inject this code to the program and execute it (see [Redirect execution](#Buffer-overflows-to-redirect-execution)) we can interact with this shell using the command seen before.
> ***PLEASE NOTE:*** In order for the shellcode to be correct, you need to set context.binary (see [ELF session](#ELF))

### ELF
ELF is a class of pwntools that it's very useful because it allows use to retrieve some information from the ELF file (i.e. the executable in Linux) without having to use debuggers, disassembler etc...
Whatever you need to do with this class, firstly we need to create an elf object (which basiacally represent the program):
```python
name_of_elf_object = ELF('path/name_of_the_program')
```
Some usefull stuff we can do is:
- find the address (in hex) of a function:
  ```python
  address = name_of_elf_object.symbols['name_of_the_function']
  ```
- retrieve the base address of ELF file which is given by ```name_of_elf_object.address```, but also update it in order to automatically update all the function and symbols addresses for you simply by doing:
  ```python
  name_of_elf_object.address = offset       #it relocates all addresses shifting them of a the offset
  ```
  (we use this especially to [bypass PIE](#Bypassing-PIE))
- retrieve the GOT (absolute/real) address of a function by doing:
    ```python
    function_gotAdd = elf.got["name_of_the_function"]
    ```
    (we can use this especially to [redirect execution overwriting GOT entries](#Exploiting-GOT-vulnerabilties-to-redirect-execution))
 
 

## Some types of attacks
### Changing ASM instructions (or bytes)
It's possible to change an ASM instruction or bytes by patching the program (see [Ida patching](#Patching-with-Ida) or [Radare2 patching](#Patching-with-Radare2)). This type of attack is especially used to reverse a jmp instruction *(e.g. from JNZ to JZ)* or to avoid an istruction to be executed by replacing it with NOPs.

### Buffer overflows to redirect execution
When a function calls another function, it:
- pushes a return pointer (EIP) to the stack so the called function knows where to return
- when the called function finishes execution, it pops it off the stack again
Because this value is saved on the stack, just like our local variables, if we write more characters than the program expects, we can overwrite the value and redirect code execution to wherever we wish.

To redirect the execution (i.e. changing where we return):
- first we need to find the padding until we begin to overwrite the return pointer (EIP)  -> use [cyclic patterns](#Cyclic-patterns)
- then we need to find what value we want to overwrite EIP to (i.e. the address of the function we want to execute) -> use [ELF .symbols function](#ELF) or use [afl command in Radare2](#Radare2-basics)
 
Basically the code in python will loke like this:
```python
from pwn import *            # import pwntools

p = process('./name_of_the_process')        # to interact with the process

payload = b'A' * n       # n is the number of bytes for the padding
payload += p32(address_to_go)   # pack the address of the function to execute

p.sendline(payload)
# if the function to execute is the opening of a shell then you need to add also:
# p.interactive()
```
 
> ***PLEASE NOTE:*** In real exploits, it's not particularly likely that you will have a suitable function lying around, so the shellcode is a way to run your own instructions, giving you the ability to run arbitrary commands on the system. So instead of jumping to a funtion we can for example jump to the address of the start of the buffer, so if we input some code in the buffer it will be executed. Here we can put some code that opens a shell (see below how to do find it).

> ***FOCUS: HOW TO FIND A SHELLCODE***
>    If you'd like to do a shellcode attack you need to input in the buffer some code that opens a shell *(i.e. usually the vulnerability is a gets(buffer) where you can overflow the buffer and put as return address the start of the buffer where you have the code of the shell, see [how to redirect execution](#Redirect-execution)).* 
>    - This shellcode can be find at https://shell-storm.org/shellcode/index.html where there are different shellcodes based on architecture and features. You can search manually or do a simple python program to search it for you. The code of this program can be e.g.:
>        ```python
>        import requests
>
>        keyword1 = "bash"       #we want a bash shell
>        keyword2 = "execve"     #we want a shell that is able to execute a program referred to by pathname
>        shellcodes = "http://shell-storm.org/api/?s=" + keyword1 + "*" + keyword2           #filter the shellcodes based on the keywords
>
>        response = requests.get(shellcodes)
>        possible_shellcodes = response.content      #get the possible shellcodes (filtered before)
>        print(possible_shellcodes)      #prints the name and the link where to find the suitable shellcodes
>        ```
>        Then you can search for the most suitable between the choices in the print (please make sure to look at the correct architecture and at the bytes needed for the shellcode).
>    
>    - Alternatively, you can create a shell using [pwntools shellcraft command](#Interactive-sessions)

### Exploiting GOT vulnerabilties to redirect execution
There’s two types of binaries on any system: statically linked and dynamically linked. Statically linked binaries are self-contained, containing all of the code necessary for them to run within the single file, and do not depend on any external libraries. Dynamically linked binaries (which are the default when you run gcc and most other compilers) do not include a lot of functions, but rely on system libraries to provide a portion of the functionality (to reduce substancially the size of the program). 

*For example, when your binary uses puts, the actual implementation of puts is part of the system C library. This means each ELF file will not carry their own version of puts compiled within it - it will instead dynamically link to the puts of the system it is on.*

> ***PLEASE NOTE:*** You may think that when libraries are on a new system, then it's just encessary to replace function calls (to these libraries) with hardcoded addresses; but the problem with this is that it would require the libraries to have a constant base address, i.e. be loaded in the same area of memory every time it's run. However, this is most of the time not true since modern systems use ASLR *(Address Space Layout Randomization )* which means libraries are loaded at different locations on each program invocation, which is possible only thanks to dynamic linking (these addresses need to be resolved every time the binary is run and to do so is rather impossible with hardcoding addresses).

Consequently, a strategy called *"Relocation"* was developed to allow looking up all of these addresses when the program was run and providing a mechanism to call these functions from libraries. The hard work of doing this is done by the PLT and the GOT which are sections within an ELF file that deal with the dynamic linking and specifically they take care of locating these *(dynamically-linked)* functions (since the program need to know the address of the functions to call them).

***The relocation: how PLT and GOT work***
PLT *(Procedure Linkage Table)* and GOT *(Global Offset Table)* work together to perform linking.
Basically what happens is that when the program calls one of the (library's) functon it's actually calling the address of the PLT corresponding to that function which they actually make another indirect call to the correspondent address of the GOT.

*For example: When you call puts() in C and compile it as an ELF executable, it is not actually puts() - instead, it gets compiled as puts@plt (you can check it out in GDB). This happens because it doesn't know where puts actually is, so it jumps to the PLT entry of puts instead. From here, puts@plt does some very specific things:*
- *If there is a GOT entry for puts, it jumps to the address stored there. *
- *If there isn't a GOT entry, it will resolve it and jump there*

> ***PLEASE NOTE:*** Since calling the PLT address of a function is equivalent to calling the function itself if we have a PLT entry for a desirable library function we can just redirect execution (normally) to its PLT entry and it will be the equivalent of calling the function directly

The GOT is basically a massive table of addresses (every library function used by the program has an entry there). These addresses are the actual (real, absolute) locations in memory of the library functions. 

So, when the PLT gets called, it reads the GOT address and redirects execution there. If the address is empty, it coordinates with the ld.so (also called the dynamic linker/loader) to get the function address and stores it in the GOT.

***Overwriting a GOT entry***

> ***PLEASE NOTE:***  GOT thing that allows a c program to call libc libraries and serve as a jumping point for the program. Therefore, we can try to hijack it, especially if ASLR is enabled, because it stays constant (the address of a GOT entry is only fixed per binary, so if two systems have the same binary running, then the GOT entry is always at the same address). This means if we modify the jumping point we can make the program execute code at a different address than intended.

The GOT address contains addresses of functions in libraries, and the GOT is within the binary, so it will always be a constant offset away from the base. Therefore, if PIE is disabled or you somehow leak the binary base (see [bypassing PIE](#Bypassing-PIE)), you know the exact address (of the GOT and so the address...) that contains a library's function's address.
You can retrieve this real/absolute address 3 different methods:
- using Radare2:
    - by doing ```pdf @ name_of_the_function``` or equivalently ```pd n @ name_of_the_function``` *(n is the number of asm instructions to display)* which will print the function disassembled and with it also the relocated address (just look at the end after the jump to the ...word of the reloc)
- using the objdump command
    - in particular by doing ```objdump --dynamic-reloc ./name_of_the_file``` which will show the real address of all the functions
- using pwntools
    - in particular by doing ```function_gotAdd = elf.got["name_of_the_function"]``` *(where elf is the object created with the context.binary setted)*, and in this case function_gotAdd* will store the real GOT address
    
You can retrieve the address where to jump instead of the GOT address found above:
- using ```afl``` command in Radare2 which will show the address of the function
- using pwntools:
    - we can use the ```functionAdd = elf.symbols["name_of_the_function"]```, and in this case *functionAdd* will store the address of the function


### Bypassing PIE
PIE (*Position Independent Executable*) if enabled (you can check it using [checksec](#Some-useful-commands)) means that every time you run the file it (meaning the binary) gets loaded into a different memory address. This means you cannot hardcode values such as function addressess without finding out where they are, i.e. if PIE is active it means the .symbols[] won't recover the correct address (it will recover the address offsetted which means every time you run it will be different).

However, since PIE executables are based around relative rather than absolute addresses, meaning that while the locations in memory are random, the offsets between different parts of the binary remain constant. 

*For example, if you know that the function main is located 0x128 bytes in memory after the base address of the binary, and you somehow find the location of main, you can simply subtract 0x128 from this to get the base address (and the same from the addresses of everything else ro retrieve the original one).*

> ***PLEASE NOTE:***  Due to the way PIE randomisation works, the base address of a PIE executable (i.e. elf.address) will always end in the hexadecimal characters 000. This is because pages are the things being randomised in memory, which have a standard size of 0x1000. So you can look at this when double-checking the base address.

So, all we need to do is find a single (original) address and PIE is bypassed, e.g. we can find the address of the main. 
We already know the original address of the main because it's the start of the process, so we can retrieve it simply by doing ```main = p.unpack()```. We also know the address of the main function that has been modified with the PIE offset thanks to ```elf.symbols["main"]```.
So we can know the PIE offset simply by doing ```main - elf.symbols["main"]```. We then have to update the addresses of all symbols (to the address without the offset caused by PIE), this can be done simply by doing:
```python  
elf.address = main - elf.symbols["main"]
```
> ***PLEASE NOTE:*** Before this remember to set the context.binary and create the elf object (that we've called *elf* here) with the context.binary.path.

Now that we know this we can redirect the execution by exploiting the vulnerability of the GOT as usual (see [exploiting GOT](Exploiting-GOT-vulnerabilties-to-redirect-execution)).



```
### Bypassing ASLR
PIE is a precondition to enable address space layout randomization (ASLR). ASLR is a security feature where the kernel (!!! not binary) loads the binary and dependencies into a random location of virtual memory each time it's run.

However, the situation is very different if the ASLR, i.e. the *Address Space Layout Randomization* is enabled. (to check if it is just try to run the program a few times and if the memory addresses always change it means it's enabled).

ASLR is a technique that is used to increase the difficulty of performing a buffer overflow attack beacuse it requires the attacker to know the location of an executable in memory (basically it randomizes the location where system executables are loaded into memory). 
In other words, since buffer overflows require an attacker to know where each part of the program is located in memory. Figuring this out is usually a difficult process of trial and error. After determining that, they must craft a payload and find a suitable place to inject it. If the attacker does not know where their target code is located, it can be difficult or impossible to exploit it.
So what ASLR does basically is that every time the program is run, components (including the stack, heap, and libraries) are moved to a different address in virtual memory. Therefore, attackers can no longer learn where their target is through trial and error, because the address will be different every time.
```


```
ROP?? Vedi segnalibro + roba stack a parte 
(secondo me metterei anche la robe della shell qui tipo)

ASM SMALL GUIDE ???

La funzione gets() acquisisce una stringa da tastiera, fino alla fine, compresi eventuali spazi e il ritorno a capo che trasforma nel carattere terminatore (\0). La funzione puts() visualizza l'intera riga di testo, ad esempio una stringa inserita da tastiera, compreso il ritorno a capo

 
 +PWNTOOLS DI TRINCAW
 offset = cyclic_find("kaaa")                                  /ritorna la distanza della stringa kaaa sul cyclic
 
 c.binary.functions["win"].address                             /ottiene l'indirizzo di un metodo all'interno del ROP 
 dst = context.binary.get_section_by_name(".data").header.     /ottiene l'indirizzo di un area di memoria
 r(r14=dst, r15=b"flag.txt")                                   /scrive su i registri dati
 r.call("system", [e.symbols["parameters"]])                   /richiama una funzione con parametri custom tramite ROP (aggiunge alla chain da richiamare)
 p.send(b"A" * 8 * 5 + r.chain())                              /invia la chain ROP creata
 
``` 

